" -*- mode: vim; tab-width: 4; indent-tabs-mode: nil; fill-column: 99 -*-
"
" ~sfiera/.vimrc
" Brief: sfiera's vimrc
" Maintainer: Chris Pickel <sfiera@sfzmail.com>
"
" Set up vim-plug {{{
call plug#begin('~/.vim/bundle')

Plug 'kana/vim-altr'
Plug 'SWIG-syntax'
Plug 'sfiera/vim-emacsmodeline'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-markdown'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'pangloss/vim-javascript'
Plug 'tikhomirov/vim-glsl'
Plug 'google/vim-maktaba'
Plug 'google/vim-glaive'
Plug 'google/vim-codefmt'
Plug 'https://chromium.googlesource.com/chromium/src/tools/gn', {'rtp': 'misc/vim'}
Plug 'scrooloose/syntastic'

if has('python')
    if v:version >= 704
        Plug 'Valloric/YouCompleteMe', {'do': './install.py --clang-completer'}
    elseif (v:version >= 703) && has('patch584')
        Plug 'Valloric/YouCompleteMe', {'do': './install.py --clang-completer'}
    endif
endif

call plug#end()
call glaive#Install()
" }}}
" Options {{{
syntax enable
colorscheme sfiera

set nocompatible
set nomodeline
set backspace=2
set showmode
set showcmd
set ruler
set foldmethod=marker
set laststatus=2
set ttyfast
set cursorline
set scrolloff=5
set scrolljump=-25

set nojoinspaces

set numberwidth=8

set hlsearch
set incsearch

set backupskip=/tmp/*,/private/tmp/*
set backupdir=~/.vimswp//
set directory=~/.vimswp//
if has('persistent_undo')
    set undodir=~/.vimswp//
    set undofile
endif

let &colorcolumn="+" . join(range(2,999),",+")

set wildmenu
set wildmode=list:longest,full

set guifont=Source\ Code\ Pro\ ExtraLight:h14
hi! link Label Statement

" Only wait (1/6)s for escape sequences.  Don't time out maps.
set notimeout
set ttimeout
set ttimeoutlen=133

set completeopt=menuone
" }}}
" Key bindings {{{

" Make Esc enter command-line mode; g[/?] hide incsearch {{{
cnoremap <silent> <Esc> <C-F>

nnoremap <silent> g/ :nohlsearch<CR>
nnoremap <silent> g? :nohlsearch<CR>
" }}}

" Use hjkl; in place of :hjkl {{{
noremap j h
noremap k j
noremap l k
noremap ; l

noremap J _
noremap K }
noremap L {
noremap : g_

nnoremap <C-W>j <C-W>h
nnoremap <C-W>k <C-W>j
nnoremap <C-W>l <C-W>k
nnoremap <C-W>; <C-W>l
nnoremap <C-W>J <C-W>H
nnoremap <C-W>K <C-W>J
nnoremap <C-W>L <C-W>K
nnoremap <C-W>: <C-W>L

noremap h :
noremap H :
noremap ยก :

noremap 0 <NOP>
noremap _ <NOP>
noremap ^ <NOP>
noremap { <NOP>
noremap } <NOP>
noremap $ <NOP>
noremap % <NOP>
" }}}

" Fix some vi inconsistencies {{{
" TODO(sfiera): make cw/cW repeat properly with .
noremap S ch
noremap Y y$
vnoremap Y yy
nnoremap cw dwi
nnoremap cW dWi
" }}}

" Rebind paired (capitals; adjacent keys) to match {{{
nnoremap <silent> u :<C-U>call repeat#wrap("u",         v:count)<CR>
nnoremap <silent> U :<C-U>call repeat#wrap("\<Lt>C-R>", v:count)<CR>

noremap q @
noremap Q q
noremap m `
noremap M m
noremap s ;
noremap S ,

nnoremap <C-R> <NOP>
noremap  @ <NOP>
noremap , <NOP>
noremap ' J
" }}}

" Make <Space> useful {{{
nnoremap <silent> <Space> :<C-U>call repeat#run(v:count)<CR>

nnoremap . <NOP>
" }}}

" g* {{{
map G g

noremap gj 0
noremap gk G
noremap gl gg
noremap g; $

noremap gh %

noremap gs *
noremap gS #

map gw <C-W>
map gW <C-W>
noremap ga <C-A>
noremap gA <C-X>
noremap gv <C-V>
noremap gV <C-V>

noremap * <NOP>
noremap # <NOP>

noremap gg :ShowHideDoc<CR>
noremap gz :YcmDiags<CR>
" }}}

" z* {{{
map Z z

nnoremap zj zc
nnoremap zJ zMzX
nnoremap zk zj
nnoremap zK zj
nnoremap zl zk
nnoremap zL zk
nnoremap z; zo
nnoremap z: zRzX

nnoremap zs :split<CR>
nnoremap zS :below split<CR>
nnoremap zd :tab split<CR>
nnoremap zD :tab split<CR>gT

nnoremap zo <NOP>
nnoremap zc <NOP>
nnoremap zM <NOP>
nnoremap zR <NOP>
nnoremap zX <NOP>
" }}}

" Alternate quickly through tabs and files {{{
nnoremap ` gt
nnoremap ~ gT
noremap <Tab> :call altr#forward()<CR>
noremap <S-Tab> :call altr#back()<CR>
nnoremap , :call altr#back()<CR>
nnoremap . :call altr#forward()<CR>
" }}}

" "in file", "a file" motions {{{
onoremap <silent>af :<C-u>normal! ggVG$<CR>
onoremap <silent>if :<C-u>normal! gg0vG$<CR>
vnoremap <silent>af ggoG$
vnoremap <silent>if ggoG$
" }}}

" Tab for columnification {{{
inoremap <expr> <Tab> InsertTab()
" }}}
" }}}
" Commands {{{
command! -bang Q :qall<bang>
command! -bang W :wall<bang>
command! -bang WQ :wqall<bang>

command! ShowHideDoc :call ShowHideDoc()

function! ShowHideDoc()
    if has('python')
        let l:python = "python << EOF"
    elseif has('python3')
        let l:python = "python3 << EOF"
    else
        return
    endif
    exec l:python
import ycm.vimsupport
old = None
if ycm.vimsupport.JumpToPreviewWindow():
    old = vim.current.buffer[:]
    ycm.vimsupport.JumpToPreviousWindow()
vim.command("YcmCompleter GetDoc")
new = None
if ycm.vimsupport.JumpToPreviewWindow():
    new = vim.current.buffer[:]
    ycm.vimsupport.JumpToPreviousWindow()
if old == new:
    vim.command("pclose")
EOF
endfunction

if has('python') || has('python3')
    if has('python3')
        let s:python = "python3 << EOF"
    else
        let s:python = "python << EOF"
    endif
    exec s:python
def InsertTab():
    if int(vim.eval("pumvisible()")):
        return r"\<C-N>"
    elif not int(vim.eval("&expandtab")):
        return r"\<Tab>"

    row, col = vim.current.window.cursor
    line = vim.current.line
    ins = col + len(line[col:]) - len(line[col:].lstrip(" "))
    before, after = line[:ins], line[ins:]
    shiftwidth = int(vim.eval("shiftwidth()"))

    width = None
    adjacent_lines = []
    for i in xrange(row - 2, -1, -1):
        if vim.current.buffer[i].strip():
            adjacent_lines.append(vim.current.buffer[i])
            break
    for i in xrange(row, len(vim.current.buffer)):
        if vim.current.buffer[i].strip():
            adjacent_lines.append(vim.current.buffer[i])
            break

    adjacent_stops = []
    for adj in adjacent_lines:
        while True:
            at = adj.rfind("  ") + 2
            if at == 1:
                break
            adjacent_stops.append(at)
            adj = adj[:at].rstrip(" ")
            if not adj:
                adjacent_stops.extend(xrange(shiftwidth, at, shiftwidth))
    try:
        width = min(stop for stop in adjacent_stops if stop > ins) - ins
    except ValueError:
        pass

    if width is None:
        if before.strip(" "):
            width = 1
        else:
            width = 1 + ((shiftwidth - ins - 1) % shiftwidth)

    if ins == col:
        return width * r"\<Space>"
    else:
        return (ins - col) * '\<Right>'
EOF
endif

function! InsertTab()
python vim.command('return "%s"' % InsertTab())
endfunction
" }}}
" Plugin settings {{{
if filereadable(expand("~/.vim/bundle/vim-altr/.git/HEAD"))
    call altr#remove_all()

    call altr#define([
    \   'include/%.h',  'include/%.hh',  'include/%.hpp',
    \   'src/%.h',      'src/%.hh',      'src/%.hpp',
    \   'src/%.c',      'src/%.cc',      'src/%.cpp',      'src/%.m',      'src/%.mm',
    \   'src/%_test.c', 'src/%_test.cc', 'src/%_test.cpp', 'src/%_test.m', 'src/%_test.mm',
    \   'src/%.*.c',    'src/%.*.cc',    'src/%.*.cpp',    'src/%.*.m',    'src/%.*.mm',
    \   ])

    call altr#define([
    \   '%.h',      '%.hh',      '%.hpp',
    \   '%.c',      '%.cc',      '%.cpp',      '%.m',      '%.mm',
    \   '%_test.c', '%_test.cc', '%_test.cpp', '%_test.m', '%_test.mm',
    \   '%.*.c',    '%.*.cc',    '%.*.cpp',    '%.*.m',    '%.test.mm',
    \   ])

    call altr#define('%.py', '%_test.py', '%.*.py')

    call altr#define('%.html', '%.css', '%.js')
endif

let g:ycm_check_if_ycm_core_present = 0
let g:ycm_key_list_select_completion = []
let g:ycm_key_list_previous_completion = []
let g:ycm_global_ycm_extra_conf = '~/.dotfiles/vim/ycm.py'
let g:syntastic_c_compiler_options = '-fblocks'
let g:syntastic_auto_loc_list = 0

augroup autoformat_settings
    autocmd FileType bzl  AutoFormatBuffer  buildifier
    autocmd FileType go   AutoFormatBuffer  gofmt
    autocmd FileType gn   AutoFormatBuffer  gn
augroup END
" }}}
" Other files {{{
if glob(expand("~/.vimrc.local")) != ""
    source ~/.vimrc.local
endif
" }}}
